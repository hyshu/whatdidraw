# Design Document - What Did I Draw

## Overview

What Did I Draw is a drawing quiz game for Reddit's Devvit platform. Users create drawings with answers, and others guess by watching the drawing replay. The system provides scoring and per-drawing rankings.

**Core Modes:**
1. **Create Mode**: Draw with basic tools and set answer/hint
2. **Quiz Mode**: Watch replay and submit guesses for points
3. **Leaderboard Mode**: View top 5 scores per drawing

## Architecture

### System Structure

```
┌─────────────────┐         ┌─────────────────┐         ┌─────────────┐
│   Client        │  HTTP   │   Server        │  Redis  │   Storage   │
│  (Phaser.js)    │ ◄─────► │  (Handlers)     │ ◄─────► │   (Redis)   │
└─────────────────┘         └─────────────────┘         └─────────────┘
```

### Component Architecture

Three core modules handle all functionality:

1. **Drawing Module**: Canvas interface with tool management
2. **Quiz Module**: Playback engine and guess handling
3. **Data Module**: Redis operations and scoring logic

## Component Integration

### Drawing Creation
```
User draws → Validate (min 1 stroke) → Sanitize text → Store to Redis → Return unique ID
```

### Quiz Gameplay
```
Load drawing → Initialize playback → User watches/guesses → Calculate score → Update rankings atomically
```

### Score Processing
```
Submit guess → Validate answer → Calculate points → Store score (atomic) → Update leaderboard → Return results
```

### Integration Points (Requirement 8)

**Drawing Creation to Storage:**
- Drawing_System sends: stroke data, answer, hint, metadata
- Storage_System generates unique ID using Redis INCR
- Storage_System returns: drawing ID
- Drawing_System displays confirmation with ID

**Storage to Playback:**
- Quiz_Interface requests drawing by ID or random
- Storage_System retrieves and decompresses data
- Playback_System receives complete drawing data
- Playback_System notifies Quiz_Interface when ready

**Playback to Scoring:**
- During playback: Playback_System tracks stroke progress
- On guess: Quiz_Interface sends guess text
- Quiz_Interface sends elapsed time
- Playback_System sends viewed stroke count
- Scoring_System receives all data for calculation

**Scoring to Storage:**
- Scoring_System calculates total score
- Storage_System persists score atomically
- Storage_System updates leaderboard in same transaction
- Storage_System returns updated rankings
- Quiz_Interface displays results immediately

## Data Models

### Drawing Structure
```typescript
interface Drawing {
  id: string;                // Generated by Redis INCR
  createdBy: string;         // Reddit username
  createdAt: number;         // Unix timestamp
  answer: string;            // 1-50 chars, sanitized
  hint?: string;             // 0-100 chars, sanitized
  strokes: Stroke[];         // Compressed stroke data
  totalStrokes: number;      // For score calculation
}

interface Stroke {
  points: Point[];           // Drawing coordinates
  color: string;             // Hex color code
  width: number;             // Brush size in pixels
  timestamp: number;         // Relative to drawing start
}

interface Point {
  x: number;                 // 0-600, rounded to 1 decimal
  y: number;                 // 0-400, rounded to 1 decimal
}
```

### Score Structure
```typescript
interface Score {
  id: string;                // Generated by Redis INCR
  drawingId: string;         // Reference to drawing
  userId: string;            // Reddit username
  score: number;             // Total calculated score
  baseScore: number;         // (total - viewed) × 100
  timeBonus: number;         // max(0, (60 - elapsed) × 10)
  elapsedTime: number;       // Seconds
  viewedStrokes: number;     // Strokes seen before guess
  submittedAt: number;       // Unix timestamp
}
```

## Client Components

### Drawing Canvas
- 600x400px HTML5 canvas with Phaser.js
- Tools: pen, eraser, undo, clear
- Colors: 8 options (black, red, green, blue, yellow, magenta, cyan, white)
- Brush sizes: 5 options (1px, 3px, 5px, 8px, 12px)
- Touch input support with event debouncing (50ms)
- Auto-save to localStorage every 5 seconds

### Quiz Interface
- Playback viewer with play/pause controls
- Guess input field with real-time validation
- Score breakdown display (base + time bonus)
- Top 5 leaderboard per drawing
- Progress indicator showing stroke count
- User's rank display if in top 5

### Playback Engine
- Stroke-by-stroke replay preserving original timing
- Progress tracking communicated to Quiz_Interface
- Pause state maintained during guess submission
- Completion notification to Quiz_Interface

## Server Components

### API Handlers
```
POST /api/drawings          - Save new drawing
GET  /api/drawings/:id      - Get drawing data
GET  /api/drawings/random   - Get random drawing
POST /api/scores            - Submit score
GET  /api/leaderboard/:id   - Get top 5 for drawing
```

### Drawing Handler
- Validates minimum 1 stroke, maximum 1000 strokes
- Validates coordinates within 600x400 bounds
- Sanitizes answer (1-50 chars) and hint (0-100 chars)
- Applies profanity filter using bad-words library
- Removes HTML/script tags via regex
- Compresses stroke data (rounds coordinates, shortens properties)
- Generates unique ID via Redis INCR on `drawings:id:counter`
- Returns drawing ID for confirmation

### Scoring Handler
- Validates drawing ID exists
- Validates user authentication via Reddit context
- Validates viewed_strokes ≤ total_strokes
- Validates elapsed_time ≥ 0
- Calculates: `base_score = (total_strokes - viewed_strokes) × 100`
- Calculates: `time_bonus = max(0, (60 - elapsed_seconds) × 10)`
- Total: `base_score + time_bonus`
- Updates rankings atomically using Redis WATCH/MULTI/EXEC
- Retries up to 3 times on transaction failure
- Returns score breakdown and updated rankings

### Data Handler
- Manages all Redis operations
- Handles compression/decompression of stroke data
- Ensures atomic score updates with retry logic
- Validates data integrity on retrieval
- Provides error recovery mechanisms

## Storage Schema

```
# ID Generation
drawings:id:counter         -> String (INCR for unique IDs)
scores:id:counter           -> String (INCR for unique IDs)

# Drawing Storage
drawings:{id}               -> Hash (compressed stroke data)
                               Fields: strokes (JSON), totalStrokes
drawings:meta:{id}          -> Hash (answer, hint, metadata)
                               Fields: answer, hint, createdBy, createdAt
drawings:list               -> List (all drawing IDs, LPUSH for newest first)

# Score Storage
scores:{drawingId}:{userId} -> Hash (score data, stores only best score)
                               Fields: score, baseScore, timeBonus, 
                                       elapsedTime, viewedStrokes, submittedAt

# Rankings (Requirement 4)
leaderboard:{drawingId}     -> Sorted Set (top scores per drawing)
                               Score: user's total score (for ranking)
                               Member: userId
                               Maintains top 5 automatically via ZADD
```

## Input Validation

### Drawing Validation
- Minimum: 1 stroke (required)
- Maximum: 1000 strokes (prevent abuse)
- Coordinates: x ∈ [0, 600], y ∈ [0, 400]
- Valid timestamps: monotonically increasing
- Color: must be in predefined palette
- Width: must be one of [1, 3, 5, 8, 12]

### Text Validation (Requirement 7)
- Answer: 1-50 characters, required
- Hint: 0-100 characters, optional
- Character set: UTF-8 (supports international characters including Japanese, emoji, etc.)
- HTML/script tag removal: `/<[^>]*>/g` regex
- XSS prevention: HTML entity encoding on display
- Profanity filter: bad-words library with default English dictionary
- Trim whitespace before validation

### Score Validation
- Drawing ID: must exist in Redis
- User: must be authenticated via Reddit context
- Viewed strokes: integer, 0 ≤ viewed ≤ total
- Elapsed time: number, ≥ 0 seconds
- Answer match: case-insensitive comparison after trim

## Data Flow

### Create Drawing Flow
1. User draws on canvas (Drawing_System)
2. Auto-save to localStorage every 5 seconds
3. Click save button
4. Client validates: minimum 1 stroke
5. Client prompts for answer (1-50 chars) and optional hint (0-100 chars)
6. Send to server: strokes, answer, hint, metadata
7. Server validates: stroke count, bounds, text format
8. Server sanitizes: remove HTML/scripts, apply profanity filter
9. Server compresses stroke data (30-40% reduction)
10. Server generates ID: Redis INCR on `drawings:id:counter`
11. Server stores: `drawings:{id}`, `drawings:meta:{id}`, update `drawings:list`
12. Server returns: drawing ID
13. Client displays: success message with ID
14. Client clears localStorage draft
15. Client offers: "Create Another" or "Play Quiz"

### Quiz Flow
1. User selects "Play Quiz" (Quiz_Interface)
2. Client requests: random drawing from server
3. Server queries: RANDOMKEY from `drawings:list` or LINDEX with random index
4. Server retrieves: `drawings:{id}` and `drawings:meta:{id}`
5. Server decompresses: stroke data
6. Server sends: complete drawing data to client
7. Client initializes: Playback_System with drawing data
8. Playback_System notifies: Quiz_Interface ready for interaction
9. User clicks: play button
10. Playback_System: replays strokes with timing, tracks progress
11. User submits: guess during playback
12. Playback_System: pauses, sends viewed stroke count
13. Client sends: guess text, elapsed time, viewed strokes
14. Server validates: answer match (case-insensitive, trimmed)
15. Server calculates: base score and time bonus
16. Server updates: score and leaderboard atomically (see below)
17. Server returns: score breakdown, rankings, user's rank
18. Client displays: results, updated top 5 leaderboard
19. Client offers: "Play Another" or "Create Drawing"

### Atomic Score Update (Requirement 9)
```
# Retry loop: up to 3 attempts
For attempt in 1..3:
  WATCH scores:{drawingId}:{userId}
  WATCH leaderboard:{drawingId}
  
  # Get existing score
  existingScore = HGET scores:{drawingId}:{userId} "score"
  
  # Only update if new score is better
  IF newScore > existingScore OR existingScore is NULL:
    MULTI
      # Update user's score
      HMSET scores:{drawingId}:{userId}
        score: newScore
        baseScore: baseScore
        timeBonus: timeBonus
        elapsedTime: elapsedTime
        viewedStrokes: viewedStrokes
        submittedAt: timestamp
      
      # Update leaderboard (keeps top scores automatically)
      ZADD leaderboard:{drawingId} newScore userId
      
      # Trim to top 5 only
      ZREMRANGEBYRANK leaderboard:{drawingId} 0 -6
    EXEC
    
    IF EXEC succeeded:
      Break retry loop
    ELSE:
      IF attempt < 3:
        Wait 10ms * attempt (exponential backoff)
        Continue retry loop
      ELSE:
        Return error to client
```

## State Management (Requirement 10)

### Phaser Scene Management
- **Purpose**: Handle active game state and rendering
- **Scenes**:
  - `DrawingScene`: Active canvas, tools, stroke recording
  - `QuizScene`: Playback engine, guess input, timer
  - `LeaderboardScene`: Rankings display per drawing
- **Transitions**: Managed by Phaser scene stack

### localStorage Usage
- **Purpose**: Persist state across page refreshes and mode transitions
- **Keys**:
  - `draft:strokes`: Auto-saved drawing strokes (cleared on save)
  - `quiz:state:{drawingId}`: Active quiz progress (cleared on complete)
  - `session:lastMode`: Last active mode for return navigation
- **Behavior**:
  - Auto-save drawing every 5 seconds
  - Restore draft on return to Create Mode
  - Preserve quiz state when switching to Create Mode
  - Clear quiz state on completion or explicit quit

### Transition Handling
- **Create → Quiz**: 
  - If unsaved strokes exist: prompt "Save drawing before leaving?"
  - Save current mode to `session:lastMode`
  - Switch to QuizScene
- **Quiz → Create**: 
  - Save quiz state to `quiz:state:{drawingId}` if in progress
  - Switch to DrawingScene
  - Restore draft if exists
- **Any → Leaderboard**: 
  - Maintain previous mode in `session:lastMode`
  - Display rankings
  - Back button returns to saved mode

### Reddit Authentication
- User context maintained across all components via Devvit context
- Username used for score attribution and leaderboard display
- Session persists throughout Reddit app lifecycle

## Navigation

### Mode Structure
```
Home / Main Menu
 ├─ Create Drawing
 │   ├─ Canvas (active drawing)
 │   └─ Save → Confirmation → Create Another | Play Quiz
 ├─ Play Quiz
 │   ├─ Random Drawing Selection
 │   ├─ Playback & Guess
 │   └─ Results → Play Another | Create Drawing | View Leaderboard
 └─ Leaderboard (per drawing)
     ├─ Top 5 Scores
     ├─ User's Rank (if applicable)
     └─ Back to Previous Mode
```

### Unified Navigation
- Back button available in all modes
- Returns to previous mode based on `session:lastMode`
- Main menu accessible from all scenes
- Reddit app integration maintains overall navigation context

## Error Handling

### Client Errors
- **Canvas initialization failure**: 
  - Display: "Unable to load drawing canvas. Please refresh the page."
  - Log: Error details to console
  - Action: Provide refresh button

- **Network timeout** (30 seconds):
  - Display: "Connection timeout. Retrying..."
  - Action: Retry with exponential backoff (1s, 2s, 4s)
  - Max retries: 3
  - Final failure: "Unable to connect. Please check your connection."

- **Invalid input**:
  - Display: Inline validation feedback below input field
  - Examples: "Answer must be 1-50 characters", "Drawing must have at least 1 stroke"
  - Prevent submission until valid

- **localStorage full**:
  - Display: "Unable to auto-save. Please save your drawing manually."
  - Action: Disable auto-save, keep manual save functional

### Server Errors
- **Missing drawing (404)**:
  - Response: `{error: "NOT_FOUND", message: "Drawing not found", code: 404}`
  - Client display: "This drawing no longer exists. Try another one."
  - Action: Offer "Play Another Quiz" button

- **Invalid input (400)**:
  - Response: `{error: "INVALID_INPUT", message: "Answer must be 1-50 characters", code: 400}`
  - Client display: Show specific validation message
  - Action: Allow user to correct and resubmit

- **Redis connection failure (500)**:
  - Response: `{error: "SERVER_ERROR", message: "Unable to process request. Please try again.", code: 500}`
  - Server action: Log error with full context for admin review
  - Client display: Generic error with retry option
  - Retry: Same as network timeout

- **Atomic transaction failure** (Requirement 9):
  - Server action: Retry up to 3 times with exponential backoff
  - After 3 failures: Return 500 error
  - Client: Display retry option to user

### Error Format
```typescript
interface ErrorResponse {
  error: "NOT_FOUND" | "INVALID_INPUT" | "SERVER_ERROR" | "UNAUTHORIZED";
  message: string;  // User-friendly description
  code: 400 | 404 | 500 | 401;
  details?: any;    // Optional technical details for debugging
}
```

## Performance Optimization

### Compression (Requirement 6)
- **Coordinate rounding**: 3 decimals → 1 decimal (e.g., 123.456 → 123.5)
- **Property shortening**: 
  - `points` → `p`
  - `color` → `c`
  - `width` → `w`
  - `timestamp` → `t`
  - `x` → `x` (keep short)
  - `y` → `y` (keep short)
- **Result**: 30-40% size reduction
- **Quality**: No visible impact on drawing replay

### Caching
- **Leaderboard cache**: Top 5 per drawing
  - Key: `cache:leaderboard:{drawingId}`
  - TTL: 5 minutes
  - Invalidate: On new score submission for that drawing
  
- **Frequently accessed drawings**: 
  - Key: `cache:drawing:{drawingId}`
  - TTL: 10 minutes
  - Criteria: Accessed 10+ times in last hour
  
- **Cache strategy**: 
  - Check cache first
  - On miss: fetch from primary storage, populate cache
  - On TTL expiry: lazy refresh on next request

### Mobile Optimization (Requirement 5)
- **Touch events**: Debounce at 50ms to prevent excessive events
- **Canvas rendering**: Use requestAnimationFrame for smooth drawing
- **Responsive breakpoint**: 768px
  - Below: Single column layout, larger touch targets (44px minimum)
  - Above: Two column layout where appropriate
- **Touch targets**: Minimum 44×44px for all interactive elements
- **Viewport**: `<meta name="viewport" content="width=device-width, initial-scale=1">`

## Security

### Input Sanitization (Requirement 7)
- **HTML/Script removal**: Strip all tags using `/<[^>]*>/g`
- **XSS prevention**: HTML entity encode on display (`&lt;` `&gt;` `&quot;` `&#x27;` `&#x2F;`)
- **Profanity filter**: bad-words library with English dictionary
- **SQL injection**: N/A (Redis key-value store, no SQL)
- **Command injection**: Validate all Redis keys follow expected patterns

### Data Validation
- All numeric inputs: validate type and range
- All string inputs: validate length and character set
- All IDs: validate format before Redis queries
- All user content: sanitize before storage and display

### Authentication
- Reddit user context verified on all API calls
- User ID used for score attribution
- No separate authentication system needed (handled by Devvit)

## Testing Requirements

### Unit Tests
- Drawing validation logic: stroke count, bounds, format
- Score calculation algorithm: base score, time bonus, edge cases
- Data compression/decompression: round-trip integrity
- Text sanitization: HTML removal, profanity filter, XSS prevention
- Atomic transaction retry logic: success, failure, partial failure

### Integration Tests
- Drawing save → retrieve flow: full cycle with compression
- Score submission → ranking update: atomic operation verification
- Complete quiz gameplay cycle: drawing load → playback → guess → score
- Concurrent score submissions: verify atomic updates prevent race conditions
- localStorage state management: save/restore across transitions

### Performance Tests
- Canvas with 500+ strokes: rendering performance, memory usage
- Concurrent score submissions: 10+ simultaneous users on same drawing
- Mobile touch responsiveness: input lag measurement, 60fps target
- Redis operations: query time under 50ms for 95th percentile
- Compression efficiency: verify 30-40% reduction across sample set

### Error Handling Tests
- Network failures: timeout, retry logic, error display
- Invalid inputs: validation messages, submission prevention
- Redis failures: transaction retries, error recovery
- Concurrent update conflicts: WATCH/MULTI/EXEC behavior

## Design Decisions

### Fixed Canvas Size (600×400px)
- **Rationale**: Consistent aspect ratio (3:2) across all devices
- **Benefit**: Fits mobile screens in portrait orientation
- **Benefit**: Maintains drawing proportions for fair comparison
- **Tradeoff**: Not full-screen on larger devices (acceptable)

### Stroke-Based Storage
- **Rationale**: Enables timed replay of drawing process
- **Benefit**: Smaller size than bitmap images
- **Benefit**: Smooth animation during playback
- **Tradeoff**: More complex than image storage (worth it for core gameplay)

### Top 5 Leaderboard Only (per drawing)
- **Rationale**: Sufficient for competitive motivation
- **Benefit**: Reduces storage complexity (Requirement 4)
- **Benefit**: Faster Redis queries (ZRANGE 0 4)
- **Tradeoff**: Users below rank 5 don't see their rank (acceptable for simplicity)

### Single Compression Strategy
- **Rationale**: 30-40% reduction without quality loss (Requirement 6)
- **Benefit**: Simple implementation and maintenance
- **Benefit**: Predictable performance characteristics
- **Tradeoff**: Not optimal for all drawing types (acceptable tradeoff)

### Atomic Score Updates with WATCH/MULTI/EXEC
- **Rationale**: Prevents race conditions in concurrent submissions (Requirement 9)
- **Benefit**: Ensures data consistency between scores and rankings
- **Benefit**: Handles multiple simultaneous guesses safely
- **Implementation**: Retry up to 3 times with exponential backoff
- **Tradeoff**: Slightly higher latency under contention (rare occurrence)

### No Weekly/Global Rankings
- **Rationale**: Per-drawing rankings sufficient for core gameplay
- **Benefit**: Reduces storage complexity
- **Benefit**: Clearer competition context (same drawing)
- **Tradeoff**: No cross-drawing competition (out of scope)

### localStorage + Phaser Scene Management
- **Rationale**: Each serves distinct purpose (Requirement 10)
- **localStorage**: Persist across refreshes, background auto-save
- **Phaser Scenes**: Active game state and rendering
- **Benefit**: Smooth transitions without data loss
- **Benefit**: Auto-save doesn't interfere with active gameplay

### bad-words Library for Profanity Filtering
- **Rationale**: Mature, maintained library with reasonable default dictionary
- **Benefit**: Covers common profanity without manual list maintenance
- **Benefit**: Easy to extend with custom word lists if needed
- **Tradeoff**: Not perfect (no filter is), but good baseline

### Redis INCR for ID Generation
- **Rationale**: Atomic, sequential, guaranteed unique
- **Benefit**: Simple implementation
- **Benefit**: Predictable performance
- **Tradeoff**: Sequential IDs reveal creation order (acceptable for this use case)

This design provides complete functionality for all requirements while maintaining simplicity, performance, and data integrity.